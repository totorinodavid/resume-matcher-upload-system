üîß ULTIMATIVER STRIPE WEBHOOK FIX PROMPT
=========================================

Du bist ein Expert-Entwickler f√ºr Stripe-Integration. Analysiere ZUERST diese offiziellen Stripe-Dokumentations-Links und implementiere dann die vollst√§ndige L√∂sung:

üìö STRIPE DOKUMENTATION - PFLICHTLEKT√úRE:
1. Webhooks √úbersicht: https://stripe.com/docs/webhooks
2. Signatur-Verifikation: https://stripe.com/docs/webhooks/signatures  
3. Webhook Quickstart: https://stripe.com/docs/webhooks/quickstart
4. Dashboard Webhook Setup: https://stripe.com/docs/webhooks#register-webhook
5. API Webhook Endpoints: https://stripe.com/docs/api/webhook_endpoints
6. Connect Webhooks: https://stripe.com/docs/connect/webhooks
7. Stripe CLI Listen: https://stripe.com/docs/stripe-cli/listen
8. Stripe CLI Referenz: https://stripe.com/docs/stripe-cli
9. CLI Listen Details: https://stripe.com/docs/stripe-cli/listen
10. Events triggern: https://stripe.com/docs/stripe-cli/triggers
11. CLI Getting Started: https://stripe.com/docs/stripe-cli#get-started
12. Endpoint Secret finden: https://stripe.com/docs/webhooks/signatures#verify-official-libraries
13. Node.js Webhook Guide: https://stripe.com/docs/webhooks/quickstart#node
14. Python Webhook Guide: https://stripe.com/docs/webhooks/quickstart#python
15. Stripe Node SDK: https://github.com/stripe/stripe-node
16. Stripe Samples: https://github.com/stripe-samples
17. Connect Sample: https://github.com/stripe-samples/connect-rocket-deliveries
18. No Signatures Found Fix: https://stackoverflow.com/questions/54585106
19. ConstructEvent Troubleshooting: https://stackoverflow.com/questions/70926732
20. Express Raw Body Issue: https://github.com/stripe/stripe-node/issues/955
21. Next.js Raw Body Guide: https://github.com/vercel/next.js/discussions/12079

LESE DIESE LINKS und nutze die Informationen f√ºr die Implementation!

PROBLEM ANALYSE:
- Resume Matcher Backend auf: https://resume-matcher-backend-j06k.onrender.com
- Stripe Webhooks kommen an "/" an (Emergency Route funktioniert)
- Credits werden nicht zu User-Accounts hinzugef√ºgt trotz erfolgreicher Payments
- Aktuelle User ID: e747de39-1b54-4cd0-96eb-e68f155931e2

STRIPE DOKUMENTATION ERKENNTNISSE (aus obigen Links):
‚úÖ ALLE Webhooks werden signiert (Test + Live Mode) - Quelle: https://stripe.com/docs/webhooks/signatures
‚úÖ Stripe-Signature Header Format: "t=timestamp,v1=signature" - Quelle: https://stripe.com/docs/webhooks/signatures
‚úÖ Raw Body erforderlich f√ºr Signatur-Verifikation - Quelle: https://stripe.com/docs/webhooks/quickstart
‚úÖ Zeitstempel-Toleranz: 5 Minuten (300 Sekunden) - Quelle: https://stripe.com/docs/webhooks/signatures
‚úÖ HMAC-SHA256 Verifikation erforderlich - Quelle: https://stripe.com/docs/webhooks/signatures
‚úÖ FastAPI muss raw body lesen BEVOR JSON-Parsing - Quelle: https://github.com/vercel/next.js/discussions/12079
‚úÖ Stripe CLI f√ºr Testing: stripe listen --forward-to - Quelle: https://stripe.com/docs/stripe-cli/listen
‚úÖ Event triggering: stripe trigger checkout.session.completed - Quelle: https://stripe.com/docs/stripe-cli/triggers
‚úÖ Python Webhook Implementation - Quelle: https://stripe.com/docs/webhooks/quickstart#python

CURRENT BACKEND STRUKTUR (EXAKTE DATEIPFADE):
- apps/backend/app/api/router/webhooks.py (Stripe Webhook Handler)
- apps/backend/app/base.py (Emergency "/" Route)
- POST "/" Route f√§ngt Stripe Webhooks ab
- User-Agent Detection: "Stripe/1.0"

CURRENT PROBLEMATIC CODE ANALYSIS:
Das aktuelle System hat diese Issues:
1. ‚ùå Signatur-Verifikation funktioniert, aber User Resolution schl√§gt fehl
2. ‚ùå _resolve_user_id() findet User nicht trotz korrekter metadata  
3. ‚ùå CreditsService.credit_purchase() wird nie erreicht
4. ‚ùå Logs zeigen "no_user_mapping" - User-ID Resolution ist das Problem!

AKTUELLE WEBHOOK IMPLEMENTATION (apps/backend/app/api/router/webhooks.py):
```python
async def _resolve_user_id(db: AsyncSession, stripe_customer_id: Optional[str], meta: dict) -> Optional[str]:
    # 1) Mapping table lookup
    if stripe_customer_id:
        row = await db.execute(StripeCustomer.__table__.select().where(...))
        # PROBLEM: Neue Users haben keine StripeCustomer Eintr√§ge!
    
    # 2) Metadata fallback 
    if isinstance(meta, dict):
        user_id = meta.get("user_id")
        if user_id:
            return user_id
        # PROBLEM: Hier schl√§gt es fehl - metadata ist leer oder falsch!
```

EMERGENCY ROUTE (apps/backend/app/base.py):
```python
@app.post("/", include_in_schema=False)
async def _stripe_webhook_emergency(request: Request, db: AsyncSession = Depends(get_db_session)):
    user_agent = request.headers.get("user-agent", "")
    if "Stripe/1.0" in user_agent:
        return await stripe_webhook(request, db)
    # PROBLEM: Dieser Code funktioniert, aber stripe_webhook() schl√§gt bei User Resolution fehl!
```

AUFGABE - TIEFGREIFENDE L√ñSUNG:
Implementiere eine VOLLST√ÑNDIGE, PRODUCTION-READY Stripe Webhook L√∂sung die diese EXAKTEN Probleme behebt:

1. KORREKTE SIGNATUR-VERIFIKATION (basierend auf https://stripe.com/docs/webhooks/signatures):
‚úÖ BEREITS FUNKTIONAL - stripe.Webhook.construct_event() arbeitet korrekt

2. USER RESOLUTION FIX (KRITISCHES PROBLEM):
```python
async def _resolve_user_id_FIXED(db: AsyncSession, stripe_customer_id: Optional[str], meta: dict) -> Optional[str]:
    """NEUER ANSATZ: Robuste User-ID Resolution"""
    # 1. DIREKTE Metadata-Pr√ºfung ZUERST (nicht erst StripeCustomer lookup!)
    if isinstance(meta, dict) and meta.get("user_id"):
        user_id = str(meta["user_id"]).strip()
        if user_id:
            logger.info(f"‚úÖ User-ID from metadata: {user_id}")
            return user_id
    
    # 2. StripeCustomer lookup als Fallback
    if stripe_customer_id:
        # KORRIGIERTE SQLAlchemy Query
        from app.models import StripeCustomer
        result = await db.execute(
            select(StripeCustomer.user_id).where(StripeCustomer.stripe_customer_id == stripe_customer_id)
        )
        row = result.first()
        if row and row[0]:
            return str(row[0])
    
    # 3. DEBUGGING: Log alle verf√ºgbaren Daten
    logger.error(f"‚ùå USER RESOLUTION FAILED:")
    logger.error(f"   stripe_customer_id: {stripe_customer_id}")
    logger.error(f"   metadata type: {type(meta)}")
    logger.error(f"   metadata content: {meta}")
    if isinstance(meta, dict):
        logger.error(f"   metadata keys: {list(meta.keys())}")
        for key, value in meta.items():
            logger.error(f"   metadata[{key}] = {value} (type: {type(value)})")
    
    return None
```

3. ENHANCED WEBHOOK HANDLER (KOMPLETTE NEUFASSUNG):
```python
@app.post("/")  # Emergency route in base.py
async def stripe_webhook_handler_ULTIMATE(request: Request, db: AsyncSession = Depends(get_db_session)):
    """ULTIMATE STRIPE WEBHOOK HANDLER - L√∂st das Credit Problem f√ºr immer"""
    
    # 1. User-Agent Check (bereits funktional)
    user_agent = request.headers.get("user-agent", "")
    if "Stripe/1.0" not in user_agent:
        raise HTTPException(status_code=404, detail="Not found")
    
    # 2. Raw body + Signatur (bereits funktional)
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")
    
    if not settings.STRIPE_WEBHOOK_SECRET:
        logger.error("‚ùå STRIPE_WEBHOOK_SECRET not configured!")
        raise HTTPException(status_code=503, detail="Webhook not configured")
    
    # 3. Stripe Event Construction (bereits funktional)
    try:
        event = stripe.Webhook.construct_event(
            payload=payload,
            sig_header=sig_header,
            secret=settings.STRIPE_WEBHOOK_SECRET,
        )
        logger.info(f"‚úÖ Stripe signature verified for event: {event.get('id')}")
    except Exception as e:
        logger.error(f"‚ùå Stripe signature verification failed: {e}")
        raise HTTPException(status_code=400, detail="Invalid signature")
    
    # 4. Event Type Check
    if event.get("type") != "checkout.session.completed":
        logger.info(f"‚ÑπÔ∏è Ignoring event type: {event.get('type')}")
        return JSONResponse(status_code=200, content={"ok": True, "skipped": event.get("type")})
    
    # 5. Extract Data
    session_obj = event["data"]["object"]
    stripe_customer_id = session_obj.get("customer")
    metadata = session_obj.get("metadata", {})
    
    logger.info(f"üîç Processing checkout.session.completed:")
    logger.info(f"   Event ID: {event.get('id')}")
    logger.info(f"   Session ID: {session_obj.get('id')}")
    logger.info(f"   Customer ID: {stripe_customer_id}")
    logger.info(f"   Metadata: {metadata}")
    logger.info(f"   Payment Status: {session_obj.get('payment_status')}")
    
    # 6. FIXED User Resolution
    user_id = await _resolve_user_id_FIXED(db, stripe_customer_id, metadata)
    if not user_id:
        logger.error(f"‚ùå CRITICAL: Cannot resolve user_id!")
        logger.error(f"   This is the root cause of missing credits!")
        logger.error(f"   Event: {event.get('id')}")
        logger.error(f"   Customer: {stripe_customer_id}")
        logger.error(f"   Metadata: {metadata}")
        return JSONResponse(status_code=200, content={"ok": True, "error": "no_user_mapping"})
    
    # 7. Extract Credits
    credits = 0
    if isinstance(metadata, dict):
        credits = int(metadata.get("credits", 0))
    
    if credits <= 0:
        logger.error(f"‚ùå No credits found in metadata: {metadata}")
        return JSONResponse(status_code=200, content={"ok": True, "error": "no_credits"})
    
    # 8. Add Credits to Database
    try:
        from app.services.credits_service import CreditsService
        credits_service = CreditsService(db)
        
        # Ensure customer mapping exists
        await credits_service.ensure_customer(user_id=user_id, stripe_customer_id=stripe_customer_id)
        
        # Add credits
        await credits_service.credit_purchase(
            user_id=user_id,
            delta=credits,
            reason=f"purchase:checkout:{session_obj.get('id')}",
            stripe_event_id=event.get("id"),
        )
        
        await db.commit()
        
        logger.info(f"üéâ SUCCESS: {credits} credits added to user {user_id}")
        logger.info(f"   Event: {event.get('id')}")
        logger.info(f"   Session: {session_obj.get('id')}")
        
        return JSONResponse(status_code=200, content={
            "ok": True,
            "user_id": user_id,
            "credits_added": credits,
            "event_id": event.get("id")
        })
        
    except Exception as e:
        await db.rollback()
        logger.exception(f"‚ùå Database error adding credits: {e}")
        return JSONResponse(status_code=200, content={"ok": True, "error": f"db_error: {e}"})
```

IMPLEMENTIERUNGS-ANWEISUNGEN:

1. üìÅ DATEI UPDATES:
   - Ersetze komplett apps/backend/app/base.py POST "/" route 
   - F√ºge _resolve_user_id_FIXED zu apps/backend/app/api/router/webhooks.py hinzu
   - Importiere notwendige SQLAlchemy select statements
   - Teste mit User ID: e747de39-1b54-4cd0-96eb-e68f155931e2

2. üîß ENVIRONMENT VARIABLES:
   - STRIPE_WEBHOOK_SECRET=whsec_... (von Dashboard)
   - STRIPE_SECRET_KEY=sk_test_... oder sk_live_...
   - Logging auf INFO level f√ºr Debugging

3. üß™ TESTING PROTOCOL:
   - Teste zuerst mit Stripe CLI: stripe trigger checkout.session.completed
   - √úberpr√ºfe Logs auf "SUCCESS: X credits added"
   - Validiere Datenbank: User Credits tats√§chlich erh√∂ht
   - Teste mit echtem Payment √ºber Frontend

4. üö® KRITISCHE DEBUGGING AUSGABEN:
   - JEDER Schritt muss geloggt werden
   - User Resolution Details komplett ausgeben
   - Metadata vollst√§ndig loggen (Keys + Values + Types)
   - Database Commit/Rollback Status

5. ‚ö° PERFORMANCE REQUIREMENTS:
   - Response unter 5 Sekunden
   - Database Transaction atomicity
   - Idempotency durch stripe_event_id
   - Proper async/await patterns

DAS L√ñST ENDG√úLTIG:
‚úÖ Missing Credits Problem (Root Cause: User Resolution)
‚úÖ Metadata Parsing Issues
‚úÖ Database Transaction Problems  
‚úÖ Logging & Debugging Visibility
‚úÖ Production Stability

TECHNISCHE SPEZIFIKATIONEN:
- FastAPI async/await patterns
- Raw body: await request.body()
- Header: request.headers.get("stripe-signature")
- SQLAlchemy async sessions
- Proper exception handling

RESULT ERWARTUNG:
Nach Implementation soll das System:
‚úÖ Stripe Webhooks korrekt empfangen
‚úÖ Signaturen verifizieren  
‚úÖ Credits automatisch hinzuf√ºgen
‚úÖ Error-resistant sein
‚úÖ Production-ready sein

VALIDIERUNG mit Stripe CLI (aus https://stripe.com/docs/stripe-cli):
Teste mit echten Stripe CLI Commands:
```bash
# CLI installieren: https://stripe.com/docs/stripe-cli#install
stripe login

# Webhook forwarding: https://stripe.com/docs/stripe-cli/listen  
stripe listen --forward-to https://resume-matcher-backend-j06k.onrender.com/

# Event triggering: https://stripe.com/docs/stripe-cli/triggers
stripe trigger checkout.session.completed --add checkout_session:metadata[user_id]=e747de39-1b54-4cd0-96eb-e68f155931e2 --add checkout_session:metadata[credits]=100
```

TROUBLESHOOTING REFERENZEN:
- Signature Verification Errors: https://stackoverflow.com/questions/54585106
- Raw Body Issues: https://github.com/stripe/stripe-node/issues/955  
- FastAPI Raw Body: https://github.com/vercel/next.js/discussions/12079

IMPLEMENTIERE JETZT eine vollst√§ndige L√∂sung die das Credit-Problem f√ºr immer behebt!
Nutze die obigen Links als Referenz und implementiere nach den offiziellen Stripe-Standards!
